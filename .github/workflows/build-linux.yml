name: Build Linux Executable

on:
  workflow_call:
    outputs:
      artifact-name:
        description: "Name of the Linux artifact"
        value: "StreamerViewer-linux"
  workflow_dispatch:  # Allow manual triggering

jobs:
  build-linux:
    name: Build Linux Executable
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Use system Python for browser-based approach
      run: |
        echo "Using system Python3 for browser-based approach..."
        echo "System Python version: $(python3 --version)"
        
        # Show detected Python paths dynamically
        python3 -c "
        import sys
        python_version = f'python{sys.version_info.major}.{sys.version_info.minor}'
        print(f'Detected Python version identifier: {python_version}')
        print(f'Expected system packages path: /usr/lib/python3/dist-packages')
        print(f'Expected user packages path: /home/runner/.local/lib/{python_version}/site-packages')
        "
        
        # Ensure pip is available for system python3
        python3 -m pip --version || sudo apt-get install -y python3-pip
        # Create symlink so our scripts can use 'python'
        sudo ln -sf /usr/bin/python3 /usr/local/bin/python
        # Verify setup
        python --version
        python -m pip --version

    - name: Install system dependencies for browser-based Flask app
      run: |
        sudo apt-get update
        
        # Install minimal dependencies for browser-based Flask app
        sudo apt-get install -y \
          python3-flask \
          python3-requests \
          python3-pil \
          python3-setuptools \
          python3-pkg-resources \
          python3-pip \
          libmediainfo0v5 \
          libmediainfo-dev
        
        # Install pymediainfo system-wide via pip (ensure it's in the right path)
        sudo python3 -m pip install pymediainfo
        
        # Also install in user directory as fallback for PyInstaller
        python3 -m pip install --user pymediainfo
        
        # Try to copy the mediainfo library files that pymediainfo needs
        echo "Locating libmediainfo shared libraries..."
        find /usr/lib* -name "*mediainfo*" -type f 2>/dev/null || echo "No mediainfo libraries found"
        
        echo "Current Python: $(python --version)"
        echo "Python path: $(which python)"
        
        # Clean pip environment  
        python3 -m pip install --upgrade pip setuptools wheel

    - name: Install minimal Python dependencies via pip
      run: |
        # Browser-based approach - minimal dependencies
        echo "Installing minimal pip dependencies for browser-based app..."
        
        # Install only essential packages not available as system packages:
        python3 -m pip install --user pyinstaller  # Not available as system package
        python3 -m pip install --user requests-toolbelt  # Extension, not in system
        
        # Create a runtime hook for pymediainfo
        mkdir -p hooks
        cat > hooks/hook-pymediainfo.py << 'EOF'
        # PyInstaller hook for pymediainfo
        from PyInstaller.utils.hooks import collect_all
        
        datas, binaries, hiddenimports = collect_all('pymediainfo')
        
        # Add additional paths where mediainfo library might be found
        import os
        mediainfo_paths = [
            '/usr/lib/x86_64-linux-gnu',
            '/usr/lib',
            '/lib/x86_64-linux-gnu',
            '/lib'
        ]
        
        for path in mediainfo_paths:
            for lib in ['libmediainfo.so.0', 'libmediainfo.so']:
                lib_path = os.path.join(path, lib)
                if os.path.exists(lib_path):
                    binaries.append((lib_path, '.'))
                    print(f"Added mediainfo library: {lib_path}")
        EOF
        
        echo "Created PyInstaller hook for pymediainfo"
        
        # Verify pymediainfo is available (should be installed both system-wide and user)
        echo "Verifying pymediainfo installation..."
        python3 -c "import pymediainfo; print('✓ pymediainfo available:', pymediainfo.__file__)" || echo "✗ pymediainfo not available"
        
        # Show Python path for debugging
        echo "Python module search paths:"
        python3 -c "import sys; print('\\n'.join(sys.path))"
        
        # Verify all system packages are accessible
        echo "Verifying all system packages are accessible..."
        python3 -c "import flask; print('✓ Flask from system packages')" || echo "✗ Flask not available"
        python3 -c "import requests; print('✓ Requests from system packages')" || echo "✗ Requests not available"  
        python3 -c "from PIL import Image; print('✓ Pillow from system packages')" || echo "✗ Pillow not available"
        python3 -c "import pymediainfo; print('✓ pymediainfo available system-wide')" || echo "✗ pymediainfo not available"

    - name: Verify system Python packages for browser-based app
      run: |
        echo "Using system Python packages for browser-based Flask app..."
        
        # Show system Python version and location
        echo "System Python version: $(python3 --version)"
        echo "System Python location: $(which python3)"
        echo "Available system Flask packages:"
        ls /usr/lib/python3*/dist-packages/ | grep -E "(flask|requests)" || echo "Flask packages not found"
        
        # Check if system Flask is available (no Qt needed for browser approach)
        python3 -c "
        try:
            import flask
            import requests
            from PIL import Image
            print('✓ Flask available via system packages')
            print('✓ Requests available via system packages') 
            print('✓ PIL available via system packages')
            print('✓ Browser-based approach ready')
        except ImportError as e:
            print('System packages check:', e)
            print('Will use pip-installed packages instead')
        "
        
        # Ensure we're using system python3 for PyInstaller
        echo "Setting up to use system python3 for PyInstaller..."
        which python3
        python3 -c "import sys; print('Python path:', sys.executable)"

    - name: Find mediainfo libraries for PyInstaller
      run: |
        echo "Finding mediainfo libraries for inclusion in PyInstaller..."
        
        # Find the actual libmediainfo library path
        MEDIAINFO_LIB=$(find /usr/lib* -name "libmediainfo.so.0" -type f 2>/dev/null | head -n1)
        if [ -n "$MEDIAINFO_LIB" ]; then
          echo "Found mediainfo library: $MEDIAINFO_LIB"
          echo "MEDIAINFO_LIB_PATH=$MEDIAINFO_LIB" >> $GITHUB_ENV
        else
          echo "❌ libmediainfo.so.0 not found, pymediainfo may not work in executable"
        fi
        
        # Also check for the development version
        MEDIAINFO_DEV_LIB=$(find /usr/lib* -name "libmediainfo.so" -type f 2>/dev/null | head -n1)
        if [ -n "$MEDIAINFO_DEV_LIB" ]; then
          echo "Found mediainfo dev library: $MEDIAINFO_DEV_LIB"
          echo "MEDIAINFO_DEV_LIB_PATH=$MEDIAINFO_DEV_LIB" >> $GITHUB_ENV
        fi

    - name: Create PyInstaller spec file for browser-based app
      run: |
        echo "Creating PyInstaller spec for browser-based Flask app..."
        
        # Prepare binary includes for mediainfo
        BINARY_INCLUDES="[]"
        if [ -n "$MEDIAINFO_LIB_PATH" ]; then
          echo "Including mediainfo library: $MEDIAINFO_LIB_PATH"
          BINARY_INCLUDES="[('$MEDIAINFO_LIB_PATH', '.')]"
        fi
        export BINARY_INCLUDES
        
        python -c "
        import os
        
        # Get binary includes from environment
        binary_includes = os.environ.get('BINARY_INCLUDES', '[]')
        print(f'Using binary includes: {binary_includes}')
        
        spec_content = f'''# -*- mode: python ; coding: utf-8 -*-
        # Browser-based Flask app - minimal dependencies (no Qt required)
        
        block_cipher = None
        
        a = Analysis(
            ['main.py'],
            pathex=['.'],
            binaries={binary_includes},
            datas=[
                ('templates', 'templates'),
                ('static', 'static'),
            ],
            hiddenimports=[
                # Core Flask dependencies
                'flask',
                'werkzeug',
                'werkzeug.utils',
                'jinja2',
                'markupsafe',
                'click',
                'itsdangerous',
                # HTTP requests and related
                'requests',
                'urllib3',
                'certifi', 
                'charset_normalizer',
                'idna',
                'requests_toolbelt',
                'requests_toolbelt.multipart',
                'requests_toolbelt.multipart.encoder',
                # Media info for video files
                'pymediainfo',
                # Browser launching (webbrowser is stdlib, but ensure it's included)
                'webbrowser',
                # Standard library modules that might need explicit inclusion
                'struct',
                'uuid', 
                'json',
                'threading',
                'socket',
                'ssl',  # Needed for HTTPS requests
                'glob',
                're',
                'datetime',
                'time',
                'os',
                'sys',
                'email.utils',  # Often needed by HTTP libraries
                'email.message',  # Often needed by HTTP libraries
                'zipfile',  # Critical for PyInstaller operation
                'io',  # Standard I/O operations
                'tempfile',  # Temporary files
                'shutil',  # File operations
                'subprocess',  # Process management
                'pathlib',  # Path handling
                'collections',  # Standard collections
                'functools',  # Functional tools
                'itertools',  # Iterator tools
            ],
            hookspath=['hooks'],
            hooksconfig={},
            runtime_hooks=[],
            excludes=[
                # Exclude ALL GUI frameworks - browser-based approach only
                'tkinter', 
                'webview',
                'PyQt5',
                'PyQt6', 
                'PySide2',
                'PySide6',
                'gi',
                'gtk',
                'wx',
                'kivy',
                'pygame',
                # Exclude splash screen - Linux uses browser-based approach
                'pyi_splash',
                # Exclude ALL scientific/data packages 
                'matplotlib', 
                'numpy', 
                'scipy', 
                'pandas',
                'seaborn',
                'plotly',
                'bokeh',
                'sklearn',
                'tensorflow',
                'torch',
                'keras',
                # Exclude ALL development/testing tools
                'IPython',
                'jupyter',
                'notebook',
                'sphinx',
                'pytest',
                'nose',
                'coverage',
                'mypy',
                'flake8',
                'black',
                'autopep8',
                # Exclude database engines (Flask app doesn't use them)
                'sqlite3',
                'psycopg2',
                'pymongo',
                'sqlalchemy',
                # Exclude unnecessary standard library modules
                'turtle',
                'pydoc',
                'doctest',
                'profile',
                'pstats',
                'cProfile',
                'trace',
                'lib2to3',
                'pydoc_data',
                'test',
                'tests',
                # Exclude async/multiprocessing (Flask runs single-threaded)
                'asyncio',
                'multiprocessing',
                'concurrent.futures',
                # Exclude web frameworks we don't use
                'django',
                'tornado',
                'fastapi',
                'aiohttp',
                'wsgiref',
                # Exclude XML processing (not needed)
                'xml',
                'xmlrpc',
                'lxml',
                # Exclude compression/archiving (but keep zipfile as it's essential for PyInstaller)
                'tarfile',
                'gzip',
                'bz2',
                'lzma',
            ],
            win_no_prefer_redirects=False,
            win_private_assemblies=False,
            cipher=block_cipher,
            noarchive=False,
        )
        
        pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
        
        exe = EXE(
            pyz,
            a.scripts,
            a.binaries,
            a.zipfiles,
            a.datas,
            [],
            name='StreamerViewer-Linux',
            debug=False,
            bootloader_ignore_signals=False,
            strip=True,
            upx=True,
            upx_exclude=[],  # No Qt libraries to exclude
            runtime_tmpdir=None,
            console=False,
            disable_windowed_traceback=False,
            argv_emulation=False,
            target_arch=None,
            codesign_identity=None,
            entitlements_file=None,
        )
        '''
        with open('StreamerViewer.spec', 'w') as f:
            f.write(spec_content)
        print('Linux spec file created successfully for browser-based app')
        "

    - name: Install UPX for compression
      run: |
        echo "Installing UPX for executable compression..."
        sudo apt-get install -y upx-ucl

    - name: Build executable with PyInstaller (size-optimized)
      run: |
        echo "Building size-optimized Linux executable (browser-based)..."
        
        # Test pymediainfo import before PyInstaller build
        echo "Testing pymediainfo import before build..."
        python3 -c "import pymediainfo; print('✅ pymediainfo import successful:', pymediainfo.__version__)" || echo "❌ pymediainfo import failed"
        
        # Build with verbose output to see what PyInstaller is doing
        python3 -m PyInstaller StreamerViewer.spec --noconfirm --clean --log-level INFO
        
        # Check if pymediainfo was actually included in the build
        echo "Checking if pymediainfo was included in the build..."
        if [ -f "build/StreamerViewer-Linux/Analysis-00.toc" ]; then
          echo "Searching for pymediainfo in PyInstaller analysis..."
          grep -i "pymediainfo" build/StreamerViewer-Linux/Analysis-00.toc || echo "❌ pymediainfo not found in analysis"
        fi
        
        # Compress with UPX for smaller size
        echo "Compressing executable with UPX..."
        upx --best --lzma dist/StreamerViewer-Linux || echo "UPX compression failed, continuing..."

    - name: Create artifacts directory
      run: |
        python -c "import os; os.makedirs('artifacts', exist_ok=True)"

    - name: Prepare Linux artifacts
      run: |
        python -c "
        import shutil
        shutil.copy('dist/StreamerViewer-Linux', 'artifacts/StreamerViewer-linux')
        print('Linux executable copied to artifacts')
        
        # Create desktop entry for proper GNOME integration  
        desktop_content = '[Desktop Entry]\\n'
        desktop_content += 'Version=1.0\\n'
        desktop_content += 'Type=Application\\n'
        desktop_content += 'Name=Streamer Viewer\\n'
        desktop_content += 'Comment=View and manage streaming recordings\\n'
        desktop_content += 'Exec=./StreamerViewer-linux\\n'
        desktop_content += 'Icon=application-default-icon\\n'
        desktop_content += 'Terminal=false\\n'
        desktop_content += 'Categories=AudioVideo;Video;\\n'
        desktop_content += 'StartupNotify=true\\n'
        
        with open('artifacts/StreamerViewer.desktop', 'w') as f:
            f.write(desktop_content)
        print('Desktop entry created for GNOME integration')
        "

    - name: List build output
      run: |
        python -c "
        import os
        print('Contents of artifacts directory:')
        try:
            for item in os.listdir('artifacts'):
                item_path = os.path.join('artifacts', item)
                size = os.path.getsize(item_path) if os.path.isfile(item_path) else 'DIR'
                print(f'  {item} ({size} bytes)' if size != 'DIR' else f'  {item}/ (DIR)')
        except Exception as e:
            print(f'  No artifacts directory or error: {e}')
        "

    - name: Upload Linux executable artifact
      uses: actions/upload-artifact@v4
      with:
        name: StreamerViewer-linux
        path: artifacts/*
        retention-days: 90